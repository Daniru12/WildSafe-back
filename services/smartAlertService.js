const Alert = require('../models/Alert');
const User = require('../models/User');
const Incident = require('../models/Incident');

class SmartAlertService {
  
  // Auto-generate alerts based on incident severity
  static async createIncidentAlert(incident) {
    try {
      let priority = 'MEDIUM';
      let category = 'WARNING';
      let targetRoles = ['OFFICER'];

      // Determine alert priority and category based on incident
      if (incident.severity === 'HIGH' || incident.severity === 'CRITICAL') {
        priority = 'URGENT';
        category = 'EMERGENCY';
        targetRoles = ['OFFICER', 'ADMIN'];
      } else if (incident.severity === 'MEDIUM') {
        priority = 'HIGH';
        category = 'WARNING';
      }

      // Get target users based on roles and proximity if location exists
      let users = await User.find({
        role: { $in: targetRoles },
        status: 'ACTIVE'
      }).select('_id location role');

      // If incident has location, prioritize nearby officers
      if (incident.location && incident.location.coordinates) {
        const nearbyUsers = await User.find({
          role: { $in: targetRoles },
          status: 'ACTIVE',
          location: {
            $near: {
              $geometry: incident.location,
              $maxDistance: 5000 // 5km radius
            }
          }
        }).select('_id');

        // Include nearby users first, then others
        if (nearbyUsers.length > 0) {
          users = nearbyUsers.concat(
            users.filter(u => !nearbyUsers.some(nu => nu._id.equals(u._id)))
          );
        }
      }

      const targetUsers = users.map(user => ({
        userId: user._id,
        isRead: false
      }));

      const alert = await Alert.create({
        title: `New ${incident.severity} Incident: ${incident.type}`,
        message: `A ${incident.severity.toLowerCase()} severity ${incident.type.toLowerCase()} incident has been reported. ${incident.description ? incident.description.substring(0, 200) + '...' : ''}`,
        category,
        priority,
        createdBy: incident.reportedBy,
        targetUsers,
        targetRoles,
        relatedIncident: incident._id,
        location: incident.location,
        radius: incident.location ? 5000 : 0,
        tags: ['incident', incident.type.toLowerCase(), incident.severity.toLowerCase()],
        metadata: {
          incidentId: incident._id,
          incidentType: incident.type,
          incidentSeverity: incident.severity,
          autoGenerated: true
        }
      });

      return alert;
    } catch (error) {
      console.error('Error creating incident alert:', error);
      throw error;
    }
  }

  // Create weather-based alerts
  static async createWeatherAlert(weatherData) {
    try {
      const { type, severity, location, description, expiresAt } = weatherData;

      let priority = 'LOW';
      let category = 'INFO';
      let targetRoles = ['CITIZEN', 'OFFICER'];

      if (severity === 'severe' || severity === 'extreme') {
        priority = 'URGENT';
        category = 'EMERGENCY';
        targetRoles = ['CITIZEN', 'OFFICER', 'ADMIN'];
      } else if (severity === 'moderate') {
        priority = 'MEDIUM';
        category = 'WARNING';
      }

      // Get all active users in affected area
      let users = await User.find({
        role: { $in: targetRoles },
        status: 'ACTIVE'
      }).select('_id');

      // If location provided, filter by proximity
      if (location && location.coordinates) {
        users = await User.find({
          role: { $in: targetRoles },
          status: 'ACTIVE',
          location: {
            $near: {
              $geometry: location,
              $maxDistance: 10000 // 10km radius for weather alerts
            }
          }
        }).select('_id');
      }

      if (users.length === 0) {
        return null; // No users in affected area
      }

      const targetUsers = users.map(user => ({
        userId: user._id,
        isRead: false
      }));

      const alert = await Alert.create({
        title: `Weather Alert: ${type}`,
        message: description || `${severity} ${type} conditions expected in your area.`,
        category,
        priority,
        createdBy: null, // System-generated
        targetUsers,
        targetRoles,
        location,
        radius: 10000,
        expiresAt: expiresAt || new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours default
        tags: ['weather', type.toLowerCase(), severity],
        metadata: {
          weatherType: type,
          weatherSeverity: severity,
          autoGenerated: true,
          source: 'weather_service'
        }
      });

      return alert;
    } catch (error) {
      console.error('Error creating weather alert:', error);
      throw error;
    }
  }

  // Create geofenced alerts for users entering/leaving areas
  static async createGeofenceAlert(userId, area, action) {
    try {
      const user = await User.findById(userId);
      if (!user || user.status !== 'ACTIVE') {
        return null;
      }

      const message = action === 'enter' 
        ? `You have entered ${area.name}. ${area.alertMessage || ''}`
        : `You have left ${area.name}. ${area.exitMessage || ''}`;

      const alert = await Alert.create({
        title: `Area ${action === 'enter' ? 'Entry' : 'Exit'}: ${area.name}`,
        message,
        category: area.alertCategory || 'INFO',
        priority: area.alertPriority || 'LOW',
        createdBy: null, // System-generated
        targetUsers: [{
          userId: userId,
          isRead: false
        }],
        location: area.location,
        radius: area.radius,
        tags: ['geofence', action, area.type],
        metadata: {
          areaId: area._id,
          areaName: area.name,
          areaType: area.type,
          action,
          autoGenerated: true
        }
      });

      return alert;
    } catch (error) {
      console.error('Error creating geofence alert:', error);
      throw error;
    }
  }

  // Send scheduled alerts
  static async createScheduledAlert(scheduleData) {
    try {
      const { 
        title, 
        message, 
        category, 
        priority, 
        targetRoles, 
        targetUserIds, 
        scheduledBy,
        expiresAt,
        tags,
        metadata 
      } = scheduleData;

      let users = [];

      if (targetUserIds && targetUserIds.length > 0) {
        users = await User.find({
          _id: { $in: targetUserIds },
          status: 'ACTIVE'
        }).select('_id role');
      } else if (targetRoles && targetRoles.length > 0) {
        users = await User.find({
          role: { $in: targetRoles },
          status: 'ACTIVE'
        }).select('_id role');
      }

      if (users.length === 0) {
        return null;
      }

      const targetUsers = users.map(user => ({
        userId: user._id,
        isRead: false
      }));

      const alert = await Alert.create({
        title,
        message,
        category: category || 'INFO',
        priority: priority || 'MEDIUM',
        createdBy: scheduledBy,
        targetUsers,
        targetRoles: targetRoles || [...new Set(users.map(u => u.role))],
        expiresAt,
        tags: tags || ['scheduled'],
        metadata: {
          ...(metadata || {}),
          scheduled: true,
          scheduledAt: new Date()
        }
      });

      return alert;
    } catch (error) {
      console.error('Error creating scheduled alert:', error);
      throw error;
    }
  }

  // Clean up expired alerts
  static async cleanupExpiredAlerts() {
    try {
      const result = await Alert.updateMany(
        {
          isActive: true,
          expiresAt: { $lt: new Date() }
        },
        {
          isActive: false
        }
      );

      console.log(`Deactivated ${result.modifiedCount} expired alerts`);
      return result.modifiedCount;
    } catch (error) {
      console.error('Error cleaning up expired alerts:', error);
      throw error;
    }
  }

  // Get alert analytics
  static async getAlertAnalytics(startDate, endDate) {
    try {
      const match = {
        createdAt: {
          $gte: startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days default
          $lte: endDate || new Date()
        }
      };

      const [
        totalAlerts,
        alertsByCategory,
        alertsByPriority,
        alertsByHour,
        responseStats
      ] = await Promise.all([
        Alert.countDocuments(match),
        
        Alert.aggregate([
          { $match: match },
          { $group: { _id: '$category', count: { $sum: 1 } } }
        ]),
        
        Alert.aggregate([
          { $match: match },
          { $group: { _id: '$priority', count: { $sum: 1 } } }
        ]),
        
        Alert.aggregate([
          { $match: match },
          { 
            $group: { 
              _id: { $hour: '$createdAt' }, 
              count: { $sum: 1 } 
            } 
          },
          { $sort: { '_id': 1 } }
        ]),
        
        Alert.aggregate([
          { $match: match },
          { $unwind: '$targetUsers' },
          {
            $group: {
              _id: null,
              totalRecipients: { $sum: 1 },
              readCount: {
                $sum: { $cond: ['$targetUsers.isRead', 1, 0] }
              },
              avgResponseTime: {
                $avg: {
                  $cond: [
                    '$targetUsers.isRead',
                    { $subtract: ['$targetUsers.readAt', '$createdAt'] },
                    null
                  ]
                }
              }
            }
          }
        ])
      ]);

      const responseRate = responseStats[0] 
        ? (responseStats[0].readCount / responseStats[0].totalRecipients * 100)
        : 0;

      return {
        totalAlerts,
        alertsByCategory: alertsByCategory.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        alertsByPriority: alertsByPriority.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        alertsByHour: alertsByHour.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        responseRate: Math.round(responseRate * 100) / 100,
        avgResponseTimeMs: responseStats[0] ? responseStats[0].avgResponseTime : 0
      };
    } catch (error) {
      console.error('Error getting alert analytics:', error);
      throw error;
    }
  }

  // Send bulk alerts efficiently
  static async sendBulkAlerts(alertsData) {
    try {
      const alerts = await Alert.insertMany(alertsData);
      return alerts;
    } catch (error) {
      console.error('Error sending bulk alerts:', error);
      throw error;
    }
  }
}

module.exports = SmartAlertService;